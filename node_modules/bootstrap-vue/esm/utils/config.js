import Vue from './vue';
import cloneDeep from './clone-deep';
import get from './get';
import warn from './warn';
import { isArray, isObject, isString, isUndefined } from './inspect';
import { keys } from './object'; // General BootstrapVue configuration
//
// BREAKPOINT DEFINITIONS
//
// Some components (BCol and BFormGroup) generate props based on breakpoints, and this
// occurs when the component is first loaded (evaluated), which may happen before the
// config is created/modified
//
// To get around this we make these components async (lazy evaluation)
// The component definition is only called/executed when the first access to the
// component is used (and cached on subsequent uses)
//
// See: https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components
//
// PROP DEFAULTS
//
// For default values on props, we use the default value factory function approach so
// so that the default values are pulled in at each component instantiation
//
//  props: {
//    variant: {
//      type: String,
//      default: () => getConfigComponent('BAlert', 'variant')
//    }
//  }
// prettier-ignore

var DEFAULTS = {
  // Breakpoints
  breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],
  // Component Specific defaults are keyed by the component
  // name (PascalCase) and prop name (camelCase)
  BAlert: {
    dismissLabel: 'Close',
    variant: 'info'
  },
  BBadge: {
    variant: 'secondary'
  },
  BButton: {
    variant: 'secondary'
  },
  BButtonClose: {
    // `textVariant` is `null` to inherit the current text color
    textVariant: null,
    ariaLabel: 'Close'
  },
  BCardSubTitle: {
    // BCard and BCardBody also inherit this prop
    subTitleTextVariant: 'muted'
  },
  BCarousel: {
    labelPrev: 'Previous Slide',
    labelNext: 'Next Slide',
    labelGotoSlide: 'Goto Slide',
    labelIndicators: 'Select a slide to display'
  },
  BDropdown: {
    toggleText: 'Toggle Dropdown',
    variant: 'secondary',
    splitVariant: null
  },
  BFormFile: {
    browseText: 'Browse',
    // Chrome default file prompt
    placeholder: 'No file chosen',
    dropPlaceholder: 'Drop files here'
  },
  BFormText: {
    textVariant: 'muted'
  },
  BImg: {
    blankColor: 'transparent'
  },
  BImgLazy: {
    blankColor: 'transparent'
  },
  BJumbotron: {
    bgVariant: null,
    borderVariant: null,
    textVariant: null
  },
  BListGroupItem: {
    variant: null
  },
  BModal: {
    titleTag: 'h5',
    size: 'md',
    headerBgVariant: null,
    headerBorderVariant: null,
    headerTextVariant: null,
    headerCloseVariant: null,
    bodyBgVariant: null,
    bodyTextVariant: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerTextVariant: null,
    cancelTitle: 'Cancel',
    cancelVariant: 'secondary',
    okTitle: 'OK',
    okVariant: 'primary',
    headerCloseLabel: 'Close'
  },
  BNavbar: {
    variant: null
  },
  BNavbarToggle: {
    label: 'Toggle navigation'
  },
  BProgress: {
    variant: null
  },
  BProgressBar: {
    variant: null
  },
  BSpinner: {
    variant: null
  },
  BTable: {
    selectedVariant: 'primary',
    headVariant: null,
    footVariant: null
  },
  BToast: {
    toaster: 'b-toaster-top-right',
    autoHideDelay: 5000,
    variant: null,
    toastClass: null,
    headerClass: null,
    bodyClass: null,
    solid: false
  },
  BToaster: {
    ariaLive: null,
    ariaAtomic: null,
    role: null
  },
  BTooltip: {
    delay: 0,
    boundary: 'scrollParent',
    boundaryPadding: 5
  },
  BPopover: {
    delay: 0,
    boundary: 'scrollParent',
    boundaryPadding: 5
  }
};
var BvConfig = Vue.extend({
  created: function created() {
    // Non reactive private properties
    this.$_config = {};
    this.$_cachedBreakpoints = null;
  },
  methods: {
    getDefaults: function getDefaults() {
      // Returns a copy of the defaults
      return cloneDeep(DEFAULTS);
    },
    getConfig: function getConfig() {
      // Returns a copy of the user config
      return cloneDeep(this.$_config);
    },
    resetConfig: function resetConfig() {
      // Clear the config. For testing purposes only
      this.$_config = {};
    },
    getConfigValue: function getConfigValue(key) {
      // First we try the user config, and if key not found we fall back to default value
      // NOTE: If we deep clone DEFAULTS into config, then we can skip the fallback for get
      return cloneDeep(get(this.$_config, key, get(DEFAULTS, key)));
    },
    getComponentConfig: function getComponentConfig(cmpName) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // Return the particular config value for key for if specified,
      // otherwise we return the full config
      return key ? this.getConfigValue("".concat(cmpName, ".").concat(key)) : this.getConfigValue(cmpName) || {};
    },
    getBreakpoints: function getBreakpoints() {
      // Convenience method for getting all breakpoint names
      return this.getConfigValue('breakpoints');
    },
    getBreakpointsCached: function getBreakpointsCached() {
      // Convenience method for getting all breakpoint names
      // Caches the results after first access
      if (!this.$_cachedBreakpoints) {
        this.$_cachedBreakpoints = this.getBreakpoints();
      }

      return cloneDeep(this.$_cachedBreakpoints);
    },
    getBreakpointsUp: function getBreakpointsUp() {
      // Convenience method for getting breakpoints with
      // the smallest breakpoint set as ''
      // Useful for components that create breakpoint specific props
      var breakpoints = this.getBreakpoints();
      breakpoints[0] = '';
      return breakpoints;
    },
    getBreakpointsUpCached: function getBreakpointsUpCached() {
      // Convenience method for getting breakpoints with
      // the smallest breakpoint set as ''
      // Useful for components that create breakpoint specific props
      // Caches the results after first access
      var breakpoints = this.getBreakpointsCached();
      breakpoints[0] = '';
      return breakpoints;
    },
    getBreakpointsDown: function getBreakpointsDown() {
      // Convenience method for getting breakpoints with
      // the largest breakpoint set as ''
      // Useful for components that create breakpoint specific props
      var breakpoints = this.getBreakpoints();
      breakpoints[breakpoints.length - 1] = '';
      return breakpoints;
    },
    getBreakpointsDownCached: function getBreakpointsDownCached()
    /* istanbul ignore next: we don't use this method anywhere, yet */
    {
      // Convenience method for getting breakpoints with
      // the largest breakpoint set as ''
      // Useful for components that create breakpoint specific props
      // Caches the results after first access
      var breakpoints = this.getBreakpointsCached();
      breakpoints[breakpoints.length - 1] = '';
      return breakpoints;
    },
    setConfig: function setConfig() {
      var _this = this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!isObject(config)) {
        /* istanbul ignore next */
        return;
      }

      keys(config).filter(function (cmpName) {
        return config.hasOwnProperty(cmpName);
      }).forEach(function (cmpName) {
        if (!DEFAULTS.hasOwnProperty(cmpName)) {
          /* istanbul ignore next */
          warn("config: unknown config property \"".concat(cmpName, "\""));
          /* istanbul ignore next */

          return;
        }

        var cmpConfig = config[cmpName];

        if (cmpName === 'breakpoints') {
          // Special case for breakpoints
          var breakpoints = config.breakpoints;

          if (!isArray(breakpoints) || breakpoints.length < 2 || breakpoints.some(function (b) {
            return !isString(b) || b.length === 0;
          })) {
            /* istanbul ignore next */
            warn('config: "breakpoints" must be an array of at least 2 breakpoint names');
          } else {
            _this.$_config.breakpoints = cloneDeep(breakpoints);
          }
        } else if (isObject(cmpConfig)) {
          keys(cmpConfig).filter(function (key) {
            return cmpConfig.hasOwnProperty(key);
          }).forEach(function (key) {
            if (!DEFAULTS[cmpName].hasOwnProperty(key)) {
              /* istanbul ignore next */
              warn("config: unknown config property \"".concat(cmpName, ".{$key}\""));
            } else {
              // If we pre-populate the config with defaults, we can skip this line
              _this.$_config[cmpName] = _this.$_config[cmpName] || {};

              if (!isUndefined(cmpConfig[key])) {
                _this.$_config[cmpName][key] = cloneDeep(cmpConfig[key]);
              }
            }
          });
        }
      });
    }
  }
}); // This contains user defined configuration manager object.
// This object should be treated as private!

Vue.prototype.$bvConfig = Vue.prototype.$bvConfig || new BvConfig(); // Method to get a deep clone (immutable) copy of the defaults

var getDefaults = function getDefaults() {
  return Vue.prototype.$bvConfig.getDefaults();
}; // Method to set the config
// Merges in only known top-level and sub-level keys
//   Vue.use(BootstrapVue, config)
// or
//   BootstrapVue.setConfig(config)
//   Vue.use(BootstrapVue)


var setConfig = function setConfig() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  Vue.prototype.$bvConfig.setConfig(config);
}; // Reset the user config to default
// For testing purposes only


var resetConfig = function resetConfig() {
  Vue.prototype.$bvConfig.resetConfig();
}; // Get the current user config
// For testing purposes only


var getConfig = function getConfig() {
  return Vue.prototype.$bvConfig.getConfig();
}; // Method to grab a config value based on a dotted/array notation key
// Returns a deep clone (immutable) copy


var getConfigValue = function getConfigValue(key) {
  return Vue.prototype.$bvConfig.getConfigValue(key);
}; // Method to grab a config value for a particular component.
// Returns a deep clone (immutable) copy


var getComponentConfig = function getComponentConfig(cmpName) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  // Return the particular config value for key for if specified,
  // otherwise we return the full config
  return Vue.prototype.$bvConfig.getComponentConfig(cmpName, key);
}; // Convenience method for getting all breakpoint names


var getBreakpoints = function getBreakpoints() {
  return Vue.prototype.$bvConfig.getBreakpoints();
}; // Convenience method for getting all breakpoint names
// Caches the results after first access

/* istanbul ignore next: we don't use this method directly in any components, yet */


var getBreakpointsCached = function getBreakpointsCached() {
  return Vue.prototype.$bvConfig.getBreakpointsCached();
}; // Convenience method for getting breakpoints with
// the smallest breakpoint set as ''
// Useful for components that create breakpoint specific props


var getBreakpointsUp = function getBreakpointsUp() {
  return Vue.prototype.$bvConfig.getBreakpointsUp();
}; // Convenience method for getting breakpoints with
// the smallest breakpoint set as ''
// Useful for components that create breakpoint specific props
// Caches the results after first access


var getBreakpointsUpCached = function getBreakpointsUpCached() {
  return Vue.prototype.$bvConfig.getBreakpointsUpCached();
}; // Convenience method for getting breakpoints with
// the largest breakpoint set as ''
// Useful for components that create breakpoint specific props


var getBreakpointsDown = function getBreakpointsDown() {
  return Vue.prototype.$bvConfig.getBreakpointsDown();
}; // Convenience method for getting breakpoints with
// the largest breakpoint set as ''
// Useful for components that create breakpoint specific props
// Caches the results after first access

/* istanbul ignore next: we don't use this method anywhere, yet */


var getBreakpointsDownCached = function getBreakpointsDownCached() {
  return Vue.prototype.$bvConfig.getBreakpointsDownCached();
}; // Named Exports


export { setConfig, resetConfig, getConfig, getDefaults, getConfigValue, getComponentConfig, getBreakpoints, getBreakpointsUp, getBreakpointsDown, getBreakpointsCached, getBreakpointsUpCached, getBreakpointsDownCached };