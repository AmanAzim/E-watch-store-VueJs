{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 73db2b230aee3a9b7f84","webpack:///./node_modules/cross-domain-utils/src/index.js","webpack:///./node_modules/cross-domain-utils/src/constants.js","webpack:///./node_modules/cross-domain-safe-weakmap/src/util.js","webpack:///./node_modules/cross-domain-safe-weakmap/src/weakmap.js","webpack:///./node_modules/cross-domain-safe-weakmap/src/native.js","webpack:///./src/conf/constants.js","webpack:///./src/conf/config.js","webpack:///./src/lib/util.js","webpack:///./node_modules/zalgo-promise/src/utils.js","webpack:///./node_modules/zalgo-promise/src/global.js","webpack:///./node_modules/zalgo-promise/src/promise.js","webpack:///./node_modules/zalgo-promise/src/exceptions.js","webpack:///./src/global.js","webpack:///./src/lib/serialize.js","webpack:///./src/lib/ready.js","webpack:///./src/drivers/send/strategies.js","webpack:///./src/drivers/send/index.js","webpack:///./src/drivers/listeners.js","webpack:///./src/drivers/receive/types.js","webpack:///./src/drivers/receive/index.js","webpack:///./src/public/client.js","webpack:///./src/public/server.js","webpack:///./src/public/config.js","webpack:///./src/public/index.js","webpack:///./src/clean.js","webpack:///./src/interface.js","webpack:///./src/index.js","webpack:///./node_modules/cross-domain-utils/src/util.js","webpack:///./node_modules/cross-domain-utils/src/utils.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_IMPORTED_MODULE_0__utils__","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_1__types__","PROTOCOL","WILDCARD","MOCK","FILE","ABOUT","safeIndexOf","collection","item","length","err","counter","Date","now","CrossDomainSafeWeakMap","_classCallCheck","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","weakmap","keys","values","_cleanupClosedWindows","value","isWindow","isWindowClosed","splice","isSafeToReadWrite","key","Error","entry","writable","index","push","has","undefined","getOrSet","CONSTANTS","POST_MESSAGE_TYPE","REQUEST","RESPONSE","ACK","POST_MESSAGE_ACK","SUCCESS","ERROR","POST_MESSAGE_NAMES","METHOD","HELLO","OPEN_TUNNEL","WINDOW_TYPES","FULLPAGE","POPUP","IFRAME","WINDOW_PROPS","POSTROBOT","SERIALIZATION_TYPES","PROMISE","ZALGO_PROMISE","REGEX","SEND_STRATEGIES","POST_MESSAGE","BRIDGE","GLOBAL","MOCK_PROTOCOL","FILE_PROTOCOL","BRIDGE_NAME_PREFIX","POSTROBOT_PROXY","CONFIG","map","ALLOW_POSTMESSAGE_POPUP","window","__ALLOW_POSTMESSAGE_POPUP__","BRIDGE_TIMEOUT","CHILD_WINDOW_TIMEOUT","ACK_TIMEOUT","navigator","userAgent","match","RES_TIMEOUT","ALLOWED_POST_MESSAGE_METHODS","_ALLOWED_POST_MESSAGE","ALLOW_SAME_ORIGIN","location","href","indexOf","stringifyError","level","arguments","toString","stack","message","newErr","once","method","called","apply","noop","uniqueID","chars","replace","charAt","floor","replaceObject","callback","depth","newobj","_typeof","Array","isArray","TypeError","eachArray","eachObject","each","childItem","result","isRegex","isPromise","Promise","Window","constructor","then","getGlobal","glob","global","zalgoGlobal","__zalgopromise__","flushPromises","activeCount","possiblyUnhandledPromiseHandlers","dispatchedErrors","ZalgoPromise","handler","_this","promise__classCallCheck","resolved","rejected","errorHandled","handlers","error","isAsync","res","resolve","reject","dispatch","_this2","setTimeout","promise","j","dispatchPossiblyUnhandledError","asyncReject","_this3","dispatching","_loop","_handlers$i","onSuccess","onError","flushQueue","onFinally","timeout","time","_this4","clearTimeout","toPromise","all","promises","count","results","_loop2","prom","hash","items","onPossiblyUnhandledException","cancel","context","args","delay","flush","promisesToFlush","_i2","_length2","registerSelf","methods","listenForMethods","on","origin","_ref","source","data","meth","id","matchDomain","domain","isSerialized","type","serialize__typeof","__type__","serializeMethod","destination","__id__","__name__","deserializeMethod","obj","wrapper","slice","send","_ref2","__xdomain__","deserializeZalgoPromise","__then__","sayHello","win","readyPromises","SEND_MESSAGE_STRATEGIES","serializedMessage","dom","protocol","isActuallySameDomain","getActualDomain","forEach","postMessage","sendMessage","_jsonStringify","options","isPopup","isIframe","sourceDomain","getDomain","_extends","windowType","buildMessage","__message__","__code__","code","serializePromise","serializeZalgoPromise","regex","__source__","serializeMethods","messages","replacer","indent","objectToJSON","arrayToJSON","JSON","stringify","toJSON","jsonStringify","strategyName","success","some","Boolean","status","join","responseListeners","requestListeners","WINDOW_WILDCARD","erroredResponseListeners","__DOMAIN_REGEX__","getResponseListener","deleteResponseListener","isResponseListenerErrored","getRequestListener","nameListeners","_ref3","winQualifier","winListeners","_i4","_winListeners$__DOMAI2","_length4","_ref5","listener","RECEIVE_MESSAGE_TYPES","host","pathname","ack","_RECEIVE_MESSAGE_TYPE","respond","fireAndForget","types__extends","target","originalSource","handleError","stringifyDomainPattern","response","receiveMessage","event","closed","parsedMessage","parse","receive__typeof","parseMessage","receivedMessages","deserializePromise","RegExp","deserializeRegex","deserializeMethods","messageListener","sourceElement","originalEvent","request","targetWindow","el","document","getElementById","tagName","toLowerCase","contentWindow","HTMLIFrameElement","hasResult","requestPromises","requestPromise","isAncestor","onChildWindowReady","actualDomain","responseListener","addResponseListener","ackTimeout","resTimeout","cycleTime","cycle","max","min","markResponseListenerErrored","sendToParent","getAncestor","client","listen","listenerOptions","errorHandler","requestListener","addRequestListener","_ref6","listenersCollection","_i6","_win2","_length6","_i8","_length8","_i10","_domain2","_length10","_i12","_length12","existingListener","strDomain","regexListeners","regexListener","onceFunction","errorOnClose","interval","server__typeof","runInterval","onceListener","disable","removeEventListener","parent","cleanUpWindow","popupWindowsByWin","remoteWindows","bridge","init","initialized","addEventListener","attachEvent","initOnReady","INTERFACE","allowMock","IE_WIN_ACCESS_ERROR","isAboutProtocol","canReadFromWindow","isSameDomain","mockclosed","top","iframeIndex","iframeWindows","frame","iframeFrames","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","mockUserAgent","child","actualParent","getParent","isAncestorParent","_i7","_getAllChildFrames4","getAllChildFrames","_i3","_getFrames2","getFrames","_i5","_getAllChildFrames2","childFrame","getTop","_i15","_getFrames8","_length14","getOpener","pattern","subpattern","__cross_domain_utils_window_check__","opener","mockDomain","desc","getOwnPropertyDescriptor","childParent","getParents","frames","len"],"mappings":"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","file":"post-robot.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"postRobot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postRobot\"] = factory();\n\telse\n\t\troot[\"postRobot\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 73db2b230aee3a9b7f84","/* @flow */\n\nexport * from './utils';\nexport * from './types';\nexport * from './constants';\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/index.js","/* @flow */\n\nexport const PROTOCOL = {\n    MOCK:  ('mock:' : 'mock:'),\n    FILE:  ('file:' : 'file:'),\n    ABOUT: ('about:' : 'about:')\n};\n\nexport const WILDCARD = '*';\n\nexport const WINDOW_TYPE = {\n    IFRAME: ('iframe' : 'iframe'),\n    POPUP:  ('popup' : 'popup')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/constants.js","/* @flow */\n\nexport function safeIndexOf<T>(collection : Array<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-safe-weakmap/src/util.js","/* @flow */\n\nimport { isWindow, isWindowClosed } from 'cross-domain-utils/src';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nlet defineProperty = Object.defineProperty;\nlet counter = Date.now() % 1e9;\n\nexport class CrossDomainSafeWeakMap<K : Object, V : mixed> {\n\n    name : string\n    weakmap : WeakMap<K, V>\n    keys : Array<K>\n    values : Array<V>\n\n    constructor() {\n        counter += 1;\n\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ Math.random() * 1e9 >>> 0 }__${ counter }`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys  = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows() {\n\n        let weakmap = this.weakmap;\n        let keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            let value = keys[i];\n\n            if (isWindow(value) && isWindowClosed(value)) {\n\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key : K) : boolean {\n\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key : K, value : V) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (!this.isSafeToReadWrite(key)) {\n\n            this._cleanupClosedWindows();\n\n            let keys = this.keys;\n            let values = this.values;\n            let index = safeIndexOf(keys, key);\n\n            if (index === -1) {\n                keys.push(key);\n                values.push(value);\n            } else {\n                values[index] = value;\n            }\n\n        } else {\n\n            let name = this.name;\n            let entry = key[name];\n\n            if (entry && entry[0] === key) {\n                entry[1] = value;\n            } else {\n                defineProperty(key, name, {\n                    value:    [ key, value ],\n                    writable: true\n                });\n            }\n        }\n    }\n\n    get(key : K) : V | void {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (!this.isSafeToReadWrite(key)) {\n\n            this._cleanupClosedWindows();\n\n            let keys = this.keys;\n            let index = safeIndexOf(keys, key);\n\n            if (index === -1) {\n                return;\n            }\n\n            return this.values[index];\n\n        } else {\n\n            let entry = key[this.name];\n\n            if (entry && entry[0] === key) {\n                return entry[1];\n            }\n        }\n    }\n\n    delete(key : K) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (!this.isSafeToReadWrite(key)) {\n\n            this._cleanupClosedWindows();\n\n            let keys = this.keys;\n            let index = safeIndexOf(keys, key);\n\n            if (index !== -1) {\n                keys.splice(index, 1);\n                this.values.splice(index, 1);\n            }\n\n        } else {\n\n            let entry = key[this.name];\n\n            if (entry && entry[0] === key) {\n                entry[0] = entry[1] = undefined;\n            }\n        }\n    }\n\n    has(key : K) : boolean {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (!this.isSafeToReadWrite(key)) {\n\n            this._cleanupClosedWindows();\n\n            let index = safeIndexOf(this.keys, key);\n            return index !== -1;\n\n        } else {\n\n            let entry = key[this.name];\n\n            if (entry && entry[0] === key) {\n                return true;\n            }\n\n            return false;\n        }\n    }\n\n    getOrSet(key : K, getter : () => V) : V {\n        if (this.has(key)) {\n            // $FlowFixMe\n            return this.get(key);\n        }\n\n        let value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-safe-weakmap/src/weakmap.js","/* @flow */\n\nexport function hasNativeWeakMap() : boolean {\n\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n\n        let testWeakMap = new WeakMap();\n        let testKey = {};\n        let testValue = '__testvalue__';\n\n        Object.freeze(testKey);\n\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n\n    } catch (err) {\n\n        return false;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-safe-weakmap/src/native.js","/* @flow */\n\nexport let CONSTANTS = {\n\n    POST_MESSAGE_TYPE: {\n        REQUEST:  'postrobot_message_request',\n        RESPONSE: 'postrobot_message_response',\n        ACK:      'postrobot_message_ack'\n    },\n\n    POST_MESSAGE_ACK: {\n        SUCCESS: 'success',\n        ERROR:   'error'\n    },\n\n    POST_MESSAGE_NAMES: {\n        METHOD:      'postrobot_method',\n        HELLO:       'postrobot_ready',\n        OPEN_TUNNEL: 'postrobot_open_tunnel'\n    },\n\n    WINDOW_TYPES: {\n        FULLPAGE: 'fullpage',\n        POPUP:    'popup',\n        IFRAME:   'iframe'\n    },\n\n    WINDOW_PROPS: {\n        POSTROBOT: '__postRobot__'\n    },\n\n    SERIALIZATION_TYPES: {\n        METHOD:        'postrobot_method',\n        ERROR:         'postrobot_error',\n        PROMISE:       'postrobot_promise',\n        ZALGO_PROMISE: 'postrobot_zalgo_promise',\n        REGEX:         'regex'\n    },\n\n    SEND_STRATEGIES: {\n        POST_MESSAGE: 'postrobot_post_message',\n        BRIDGE:       'postrobot_bridge',\n        GLOBAL:       'postrobot_global'\n    },\n\n    MOCK_PROTOCOL: 'mock:',\n    FILE_PROTOCOL: 'file:',\n\n    BRIDGE_NAME_PREFIX: '__postrobot_bridge__',\n    POSTROBOT_PROXY:    '__postrobot_proxy__',\n\n    WILDCARD: '*'\n};\n\nexport const POST_MESSAGE_NAMES = {\n    METHOD:      'postrobot_method',\n    HELLO:       'postrobot_hello',\n    OPEN_TUNNEL: 'postrobot_open_tunnel'\n};\n\nexport let POST_MESSAGE_NAMES_LIST : Array<string> = Object.keys(POST_MESSAGE_NAMES)\n    .map(key => POST_MESSAGE_NAMES[key]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/conf/constants.js","/* @flow */\n\nimport { CONSTANTS } from './constants';\n\nexport let CONFIG : Object = {\n\n    ALLOW_POSTMESSAGE_POPUP: ('__ALLOW_POSTMESSAGE_POPUP__' in window)\n        ? window.__ALLOW_POSTMESSAGE_POPUP__\n        : __POST_ROBOT__.__ALLOW_POSTMESSAGE_POPUP__,\n\n    BRIDGE_TIMEOUT:       5000,\n    CHILD_WINDOW_TIMEOUT: 5000,\n\n    ACK_TIMEOUT: (window.navigator.userAgent.match(/MSIE/i) !== -1 && !__TEST__) ? 10000 : 2000,\n    RES_TIMEOUT: __TEST__ ? 2000 : -1,\n    \n    ALLOWED_POST_MESSAGE_METHODS: {\n        [ CONSTANTS.SEND_STRATEGIES.POST_MESSAGE ]: true,\n        [ CONSTANTS.SEND_STRATEGIES.BRIDGE ]:       true,\n        [ CONSTANTS.SEND_STRATEGIES.GLOBAL ]:       true\n    },\n\n    ALLOW_SAME_ORIGIN: false\n};\n\nif (window.location.href.indexOf(CONSTANTS.FILE_PROTOCOL) === 0) {\n    CONFIG.ALLOW_POSTMESSAGE_POPUP = true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/conf/config.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { isPopup, isIframe, getUserAgent } from 'cross-domain-utils/src';\n\nimport { CONFIG, CONSTANTS } from '../conf';\n\n\nexport function stringifyError(err : mixed, level : number = 1) : string {\n\n    if (level >= 3) {\n        return 'stringifyError stack overflow';\n    }\n\n    try {\n        if (!err) {\n            return `<unknown error: ${ Object.prototype.toString.call(err) }>`;\n        }\n\n        if (typeof err === 'string') {\n            return err;\n        }\n\n        if (err instanceof Error) {\n            let stack = err && err.stack;\n            let message = err && err.message;\n\n            if (stack && message) {\n                if (stack.indexOf(message) !== -1) {\n                    return stack;\n                } else {\n                    return `${ message }\\n${ stack }`;\n                }\n            } else if (stack) {\n                return stack;\n            } else if (message) {\n                return message;\n            }\n        }\n\n        if (typeof err.toString === 'function') {\n            return err.toString();\n        }\n\n        return Object.prototype.toString.call(err);\n\n    } catch (newErr) { // eslint-disable-line unicorn/catch-error-name\n        return `Error while stringifying error: ${ stringifyError(newErr, level + 1) }`;\n    }\n}\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport let once = <T>(method : Function) : ((...args : Array<any>) => T | void) => {\n    if (!method) {\n        return method;\n    }\n    let called = false;\n    return function onceWrapper() : T | void {\n        if (!called) {\n            called = true;\n            return method.apply(this, arguments);\n        }\n    };\n};\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\nexport function addEventListener(obj : Object, event : string, handler : Function) : { cancel : () => void } {\n    if (obj.addEventListener) {\n        obj.addEventListener(event, handler);\n    } else {\n        obj.attachEvent(`on${ event }`, handler);\n    }\n\n    return {\n        cancel() {\n            if (obj.removeEventListener) {\n                obj.removeEventListener(event, handler);\n            } else {\n                obj.detachEvent(`on${ event }`, handler);\n            }\n        }\n    };\n}\n\nexport function uniqueID() : string {\n\n    let chars = '0123456789abcdef';\n\n    return 'xxxxxxxxxx'.replace(/./g, () => {\n        return chars.charAt(Math.floor(Math.random() * chars.length));\n    });\n}\n\ntype MixedArrayType = Array<mixed>;\n\nexport function eachArray(item : MixedArrayType, callback : (item : mixed, key : number) => mixed) {\n    for (let i = 0; i < item.length; i++) {\n        callback(item[i], i);\n    }\n}\n\nexport function eachObject(item : Object, callback : (item : mixed, key : string) => mixed) {\n    for (let key in item) {\n        if (item.hasOwnProperty(key)) {\n            callback(item[key], key);\n        }\n    }\n}\n\nexport function each<T : Object | MixedArrayType>(item : T, callback : (item : mixed, key : number | string) => mixed) {\n    if (Array.isArray(item)) {\n        eachArray(item, callback);\n    } else if (typeof item === 'object' && item !== null) {\n        eachObject(item, callback);\n    }\n}\n\nexport function replaceObject<T : Object | MixedArrayType>(item : T, callback : (item : mixed, key : number | string) => mixed, depth : number = 1) : T {\n\n    if (depth >= 100) {\n        throw new Error(`Self-referential object passed, or object contained too many layers`);\n    }\n\n    let newobj;\n\n    if (typeof item === 'object' && item !== null && !Array.isArray(item)) {\n        newobj = {};\n    } else if (Array.isArray(item)) {\n        newobj = [];\n    } else {\n        throw new TypeError(`Invalid type: ${ typeof item }`);\n    }\n\n    each(item, (childItem, key) => {\n\n        let result = callback(childItem, key);\n\n        if (typeof result !== 'undefined') {\n            // $FlowFixMe\n            newobj[key] = result;\n        } else if (typeof childItem === 'object' && childItem !== null) {\n            // $FlowFixMe\n            newobj[key] = replaceObject(childItem, callback, depth + 1);\n        } else {\n            // $FlowFixMe\n            newobj[key] = childItem;\n        }\n    });\n\n    // $FlowFixMe\n    return newobj;\n}\n\nexport function safeInterval(method : Function, time : number) : { cancel : () => void } {\n    let timeout;\n\n    function runInterval() {\n        timeout = setTimeout(runInterval, time);\n        method.call();\n    }\n\n    timeout = setTimeout(runInterval, time);\n\n    return {\n        cancel() {\n            clearTimeout(timeout);\n        }\n    };\n}\n\nexport function isRegex(item : mixed) : boolean {\n    return Object.prototype.toString.call(item) === '[object RegExp]';\n}\n\n\ntype FunctionProxy<T : Function> = (method : T) => T;\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport let weakMapMemoize : FunctionProxy<*> = <R : mixed>(method : (arg : any) => R) : ((...args : Array<any>) => R) => {\n\n    let weakmap = new WeakMap();\n\n    // eslint-disable-next-line flowtype/no-weak-types\n    return function weakmapMemoized(arg : any) : R {\n        let result = weakmap.get(arg);\n\n        if (typeof result !== 'undefined') {\n            return result;\n        }\n\n        result = method.call(this, arg);\n\n        if (typeof result !== 'undefined') {\n            weakmap.set(arg, result);\n        }\n\n        return result;\n    };\n};\n\nexport function getWindowType() : string {\n    if (isPopup()) {\n        return CONSTANTS.WINDOW_TYPES.POPUP;\n    }\n    if (isIframe()) {\n        return CONSTANTS.WINDOW_TYPES.IFRAME;\n    }\n    return CONSTANTS.WINDOW_TYPES.FULLPAGE;\n}\n\nexport function jsonStringify<T : mixed>(obj : T, replacer : ?Function, indent : number | void) : string {\n\n    let objectToJSON;\n    let arrayToJSON;\n\n    try {\n        if (JSON.stringify({}) !== '{}') {\n            // $FlowFixMe\n            objectToJSON = Object.prototype.toJSON;\n            // $FlowFixMe\n            delete Object.prototype.toJSON;\n        }\n\n        if (JSON.stringify({}) !== '{}') {\n            throw new Error(`Can not correctly serialize JSON objects`);\n        }\n\n        if (JSON.stringify([]) !== '[]') {\n            // $FlowFixMe\n            arrayToJSON  = Array.prototype.toJSON;\n            // $FlowFixMe\n            delete Array.prototype.toJSON;\n        }\n\n        if (JSON.stringify([]) !== '[]') {\n            throw new Error(`Can not correctly serialize JSON objects`);\n        }\n\n    } catch (err) {\n        throw new Error(`Can not repair JSON.stringify: ${ err.message }`);\n    }\n\n    let result = JSON.stringify.call(this, obj, replacer, indent);\n\n    try {\n        if (objectToJSON) {\n            // $FlowFixMe\n            Object.prototype.toJSON = objectToJSON; // eslint-disable-line no-extend-native\n        }\n\n        if (arrayToJSON) {\n            // $FlowFixMe\n            Array.prototype.toJSON = arrayToJSON; // eslint-disable-line no-extend-native\n        }\n\n    } catch (err) {\n        throw new Error(`Can not repair JSON.stringify: ${ err.message }`);\n    }\n\n\n    return result;\n}\n\nexport function jsonParse(item : string) : mixed {\n    return JSON.parse(item);\n}\n            \nexport function needsGlobalMessagingForBrowser() : boolean {\n\n    if (getUserAgent(window).match(/MSIE|trident|edge\\/12|edge\\/13/i)) {\n        return true;\n    }\n        \n    if (!CONFIG.ALLOW_POSTMESSAGE_POPUP) {\n        return true;\n    }\n        \n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/util.js","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        let toString = ({}).toString;\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/utils.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\ntype ZalgoGlobalType = {\n    flushPromises : Array<ZalgoPromise<mixed>>,\n    activeCount : number,\n    possiblyUnhandledPromiseHandlers : Array<<T>(mixed, ZalgoPromise<T>) => void>, // eslint-disable-line no-undef\n    dispatchedErrors : Array<mixed>\n};\n\nexport function getGlobal() : ZalgoGlobalType {\n\n    let glob;\n\n    if (typeof window !== 'undefined') {\n        glob = window;\n    } else if (typeof global !== 'undefined') {\n        glob = global;\n    } else {\n        throw new TypeError(`Can not find global`);\n    }\n\n    let zalgoGlobal = glob.__zalgopromise__ = glob.__zalgopromise__ || {};\n    zalgoGlobal.flushPromises = zalgoGlobal.flushPromises || [];\n    zalgoGlobal.activeCount = zalgoGlobal.activeCount || 0;\n    zalgoGlobal.possiblyUnhandledPromiseHandlers = zalgoGlobal.possiblyUnhandledPromiseHandlers || [];\n    zalgoGlobal.dispatchedErrors = zalgoGlobal.dispatchedErrors || [];\n\n    return zalgoGlobal;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/global.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { getGlobal } from './global';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n    stack : string\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n\n    // eslint-disable-next-line complexity\n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        getGlobal().activeCount += 1;\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    result.then(res => {\n                        promise.resolve(res);\n                    }, err => {\n                        promise.reject(err);\n                    });\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        getGlobal().activeCount -= 1;\n\n        if (getGlobal().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    }\n\n    then<X : mixed, Y : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X | Y> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed, Y : mixed>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        return this.then(undefined, onError);\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : [*] | [*, *] | [*, *, *] | [*, *, *, *] | [*, *, *, *, *] | [*, *, *, *, *, *] | [*, *, *, *, *, *, *] | [*, *, *, *, *, *, *, *] | [*, *, *, *, *, *, *, *, *] | Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            ZalgoPromise.resolve(prom).then(result => {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                promise.reject(err);\n            });\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : { [string] : * }>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, Y : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | Y), context : ?C, args : ?A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result;\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        let promise = new ZalgoPromise();\n        getGlobal().flushPromises.push(promise);\n\n        if (getGlobal().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    }\n\n    static flushQueue() {\n        let promisesToFlush = getGlobal().flushPromises;\n        getGlobal().flushPromises = [];\n\n        for (let promise of promisesToFlush) {\n            promise.resolve();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/promise.js","/* @flow */\n\nimport { getGlobal } from './global';\nimport type { ZalgoPromise } from './promise';\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (getGlobal().dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    getGlobal().dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < getGlobal().possiblyUnhandledPromiseHandlers.length; j++) {\n        getGlobal().possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed) => void) : { cancel : () => void } {\n    getGlobal().possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            getGlobal().possiblyUnhandledPromiseHandlers.splice(getGlobal().possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/exceptions.js","/* @flow */\n\nimport { CONSTANTS } from './conf';\n\nexport let global : Object = window[CONSTANTS.WINDOW_PROPS.POSTROBOT] = window[CONSTANTS.WINDOW_PROPS.POSTROBOT] || {};\n\n// Backwards compatibility\n\nglobal.registerSelf = () => {\n    // pass\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/global.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { matchDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { CONSTANTS } from '../conf';\nimport { global } from '../global';\n\nimport { once, uniqueID, replaceObject, stringifyError, isRegex } from './util';\n\nglobal.methods = global.methods || new WeakMap();\n\nexport let listenForMethods = once(() => {\n    global.on(CONSTANTS.POST_MESSAGE_NAMES.METHOD, { origin: CONSTANTS.WILDCARD }, ({ source, origin, data } : { source : CrossDomainWindowType, origin : string, data : Object }) => {\n\n        let methods = global.methods.get(source);\n\n        if (!methods) {\n            throw new Error(`Could not find any methods this window has privileges to call`);\n        }\n\n        let meth = methods[data.id];\n\n        if (!meth) {\n            throw new Error(`Could not find method with id: ${ data.id }`);\n        }\n\n        if (!matchDomain(meth.domain, origin)) {\n            throw new Error(`Method domain ${ meth.domain } does not match origin ${ origin }`);\n        }\n\n        return ZalgoPromise.try(() => {\n            return meth.method.apply({ source, origin, data }, data.args);\n\n        }).then(result => {\n\n            return {\n                result,\n                id:   data.id,\n                name: data.name\n            };\n        });\n    });\n});\n\nfunction isSerialized(item : mixed, type : string) : boolean {\n    return typeof item === 'object' && item !== null && item.__type__ === type;\n}\n\ntype SerializedMethod = {\n    __type__ : string,\n    __id__ : string,\n    __name__ : string\n};\n\nexport function serializeMethod(destination : CrossDomainWindowType, domain : string | Array<string>, method : Function, name : string) : SerializedMethod {\n\n    let id = uniqueID();\n\n    let methods = global.methods.get(destination);\n\n    if (!methods) {\n        methods = {};\n        global.methods.set(destination, methods);\n    }\n\n    methods[id] = { domain, method };\n\n    return {\n        __type__: CONSTANTS.SERIALIZATION_TYPES.METHOD,\n        __id__:   id,\n        __name__: name\n    };\n}\n\ntype SerializedError = {\n    __type__ : string,\n    __message__ : string\n};\n\nfunction serializeError(err : mixed) : SerializedError {\n    return {\n        __type__:    CONSTANTS.SERIALIZATION_TYPES.ERROR,\n        __message__: stringifyError(err),\n        // $FlowFixMe\n        __code__:    err.code\n    };\n}\n\ntype SerializePromise = {\n    __type__ : string,\n    __then__ : SerializedMethod\n};\n\nfunction serializePromise(destination : CrossDomainWindowType, domain : string | Array<string>, promise : ZalgoPromise<mixed>, name : string) : SerializePromise {\n    return {\n        __type__: CONSTANTS.SERIALIZATION_TYPES.PROMISE,\n        __then__: serializeMethod(destination, domain, (resolve, reject) => promise.then(resolve, reject), `${ name }.then`)\n    };\n}\n\nfunction serializeZalgoPromise(destination : CrossDomainWindowType, domain : string | Array<string>, promise : ZalgoPromise<mixed>, name : string) : SerializePromise {\n    return {\n        __type__: CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE,\n        __then__: serializeMethod(destination, domain, (resolve, reject) => promise.then(resolve, reject), `${ name }.then`)\n    };\n}\n\ntype SerializedRegex = {\n    __type__ : string,\n    __source__ : string\n};\n\nfunction serializeRegex(regex : RegExp) : SerializedRegex {\n    return {\n        __type__:   CONSTANTS.SERIALIZATION_TYPES.REGEX,\n        __source__: regex.source\n    };\n}\n\nexport function serializeMethods(destination : CrossDomainWindowType, domain : string | Array<string>, obj : Object) : Object {\n\n    return replaceObject({ obj }, (item, key) => {\n        if (typeof item === 'function') {\n            return serializeMethod(destination, domain, item, key.toString());\n        }\n\n        if (item instanceof Error) {\n            return serializeError(item);\n        }\n\n        if (window.Promise && item instanceof window.Promise) {\n            return serializePromise(destination, domain, item, key.toString());\n        }\n\n        if (ZalgoPromise.isPromise(item)) {\n            // $FlowFixMe\n            return serializeZalgoPromise(destination, domain, item, key.toString());\n        }\n\n        if (isRegex(item)) {\n            // $FlowFixMe\n            return serializeRegex(item);\n        }\n    }).obj;\n}\n\nexport function deserializeMethod(source : CrossDomainWindowType, origin : string, obj : Object) : Function {\n\n    function wrapper() : ZalgoPromise<mixed> {\n        let args = Array.prototype.slice.call(arguments);\n        return global.send(source, CONSTANTS.POST_MESSAGE_NAMES.METHOD, {\n            id:   obj.__id__,\n            name: obj.__name__,\n            args\n\n        }, { domain: origin, timeout: -1 }).then(({ data }) => {\n            return data.result;\n        }, err => {\n            throw err;\n        });\n    }\n\n    wrapper.__name__ = obj.__name__;\n    wrapper.__xdomain__ = true;\n\n    wrapper.source = source;\n    wrapper.origin = origin;\n\n    return wrapper;\n}\n\nexport function deserializeError(source : CrossDomainWindowType, origin : string, obj : Object) : Error {\n    let err = new Error(obj.__message__);\n    if (obj.__code__) {\n        // $FlowFixMe\n        err.code = obj.__code__;\n    }\n    return err;\n}\n\nexport function deserializeZalgoPromise(source : CrossDomainWindowType, origin : string, prom : Object) : ZalgoPromise<mixed> {\n    return new ZalgoPromise((resolve, reject) => deserializeMethod(source, origin, prom.__then__)(resolve, reject));\n}\n\nexport function deserializePromise(source : CrossDomainWindowType, origin : string, prom : Object) : ZalgoPromise<mixed> {\n    if (!window.Promise) {\n        return deserializeZalgoPromise(source, origin, prom);\n    }\n\n    return new window.Promise((resolve, reject) => deserializeMethod(source, origin, prom.__then__)(resolve, reject));\n}\n\nexport function deserializeRegex(source : CrossDomainWindowType, origin : string, item : Object) : RegExp {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp(item.__source__);\n}\n\nexport function deserializeMethods(source : CrossDomainWindowType, origin : string, obj : Object) : Object {\n\n    return replaceObject({ obj }, (item) => {\n        if (typeof item !== 'object' || item === null) {\n            return;\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.METHOD)) {\n            return deserializeMethod(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.ERROR)) {\n            return deserializeError(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.PROMISE)) {\n            return deserializePromise(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE)) {\n            return deserializeZalgoPromise(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.REGEX)) {\n            return deserializeRegex(source, origin, item);\n        }\n\n    }).obj;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/serialize.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { getAncestor, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { CONSTANTS } from '../conf';\nimport { global } from '../global';\n\nimport { noop } from './util';\n\nglobal.readyPromises = global.readyPromises || new WeakMap();\n\nexport function onHello(handler : ({ source? : CrossDomainWindowType, origin? : string }) => void) {\n    global.on(CONSTANTS.POST_MESSAGE_NAMES.HELLO, { domain: CONSTANTS.WILDCARD }, ({ source, origin }) => {\n        return handler({ source, origin });\n    });\n}\n\nexport function sayHello(win : CrossDomainWindowType) : ZalgoPromise<{ origin : string }> {\n    return global.send(win, CONSTANTS.POST_MESSAGE_NAMES.HELLO, {}, { domain: CONSTANTS.WILDCARD, timeout: -1 })\n        .then(({ origin }) => {\n            return { origin };\n        });\n}\n\nexport function initOnReady() {\n\n    onHello(({ source, origin }) => {\n        let promise = global.readyPromises.get(source) || new ZalgoPromise();\n        promise.resolve({ origin });\n        global.readyPromises.set(source, promise);\n    });\n\n    let parent = getAncestor();\n    if (parent) {\n        sayHello(parent).catch(noop);\n    }\n}\n\nexport function onChildWindowReady(win : mixed, timeout : number = 5000, name : string = 'Window') : ZalgoPromise<{ origin : string }> {\n\n    let promise = global.readyPromises.get(win);\n\n    if (promise) {\n        return promise;\n    }\n\n    promise = new ZalgoPromise();\n    global.readyPromises.set(win, promise);\n\n    if (timeout !== -1) {\n        setTimeout(() => promise.reject(new Error(`${ name } did not load after ${ timeout }ms`)), timeout);\n    }\n\n    return promise;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/ready.js","/* @flow */\n\nimport { isSameDomain, isSameTopWindow, isActuallySameDomain, getActualDomain, getDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONSTANTS } from '../../conf';\nimport { needsGlobalMessagingForBrowser } from '../../lib';\n\nexport let SEND_MESSAGE_STRATEGIES = {};\n\n\nSEND_MESSAGE_STRATEGIES[CONSTANTS.SEND_STRATEGIES.POST_MESSAGE] = (win : CrossDomainWindowType, serializedMessage : string, domain : (string | Array<string>)) => {\n\n    if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n        try {\n            require('../../compat').emulateIERestrictions(window, win);\n        } catch (err) {\n            return;\n        }\n    }\n\n    let domains;\n\n    if (Array.isArray(domain)) {\n        domains = domain;\n    } else if (typeof domain === 'string') {\n        domains = [ domain ];\n    } else {\n        domains = [ CONSTANTS.WILDCARD ];\n    }\n\n    domains = domains.map(dom => {\n\n        if (dom.indexOf(CONSTANTS.MOCK_PROTOCOL) === 0) {\n\n            if (window.location.protocol === CONSTANTS.FILE_PROTOCOL) {\n                return CONSTANTS.WILDCARD;\n            }\n\n            if (!isActuallySameDomain(win)) {\n                throw new Error(`Attempting to send messsage to mock domain ${ dom }, but window is actually cross-domain`);\n            }\n\n            // $FlowFixMe\n            return getActualDomain(win);\n        }\n\n        if (dom.indexOf(CONSTANTS.FILE_PROTOCOL) === 0) {\n            return CONSTANTS.WILDCARD;\n        }\n\n        return dom;\n    });\n\n    domains.forEach(dom => {\n        return win.postMessage(serializedMessage, dom);\n    });\n};\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n\n    let { sendBridgeMessage, needsBridgeForBrowser, isBridge } = require('../../bridge');\n\n    SEND_MESSAGE_STRATEGIES[CONSTANTS.SEND_STRATEGIES.BRIDGE] = (win : CrossDomainWindowType, serializedMessage : string, domain : string) => {\n\n        if (!needsBridgeForBrowser() && !isBridge()) {\n            return;\n        }\n\n        if (isSameDomain(win)) {\n            throw new Error(`Post message through bridge disabled between same domain windows`);\n        }\n\n        if (isSameTopWindow(window, win) !== false) {\n            throw new Error(`Can only use bridge to communicate between two different windows, not between frames`);\n        }\n\n        return sendBridgeMessage(win, serializedMessage, domain);\n    };\n}\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__ || __POST_ROBOT__.__GLOBAL_MESSAGE_SUPPORT__) {\n    \n    SEND_MESSAGE_STRATEGIES[CONSTANTS.SEND_STRATEGIES.GLOBAL] = (win : CrossDomainWindowType, serializedMessage : string) => {\n\n        if (!needsGlobalMessagingForBrowser()) {\n            return;\n        }\n\n        if (!isSameDomain(win)) {\n            throw new Error(`Post message through global disabled between different domain windows`);\n        }\n\n        if (isSameTopWindow(window, win) !== false) {\n            throw new Error(`Can only use global to communicate between two different windows, not between frames`);\n        }\n\n        // $FlowFixMe\n        let foreignGlobal = win[CONSTANTS.WINDOW_PROPS.POSTROBOT];\n\n        if (!foreignGlobal) {\n            throw new Error(`Can not find postRobot global on foreign window`);\n        }\n\n        return foreignGlobal.receiveMessage({\n            source: window,\n            origin: getDomain(),\n            data:   serializedMessage\n        });\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/send/strategies.js","/* @flow */\n\nimport { getDomain, isWindowClosed, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { CONSTANTS, CONFIG, POST_MESSAGE_NAMES_LIST } from '../../conf';\nimport { uniqueID, serializeMethods, getWindowType, jsonStringify, stringifyError } from '../../lib';\n\nimport { SEND_MESSAGE_STRATEGIES } from './strategies';\n\n\nfunction buildMessage(win : CrossDomainWindowType, message : Object, options = {}) : Object {\n\n    let id   = uniqueID();\n    let type = getWindowType();\n    let sourceDomain = getDomain(window);\n\n    return {\n        ...message,\n        ...options,\n        sourceDomain,\n        id:         message.id || id,\n        windowType: type\n    };\n}\n\n\nexport function sendMessage(win : CrossDomainWindowType, message : Object, domain : string | Array<string>) : ZalgoPromise<void> {\n    return ZalgoPromise.try(() => {\n\n        message = buildMessage(win, message, {\n            data: serializeMethods(win, domain, message.data),\n            domain\n        });\n\n        let level;\n\n        if (__DEBUG__) {\n            if (POST_MESSAGE_NAMES_LIST.indexOf(message.name) !== -1 || message.type === CONSTANTS.POST_MESSAGE_TYPE.ACK) {\n                level = 'debug';\n            } else if (message.ack === 'error') {\n                level = 'error';\n            } else {\n                level = 'info';\n            }\n\n            // eslint-disable-next-line no-console\n            console[level]('postrobot_send', message.type.replace(/^postrobot_message_/, ''), '::', message.name, '::', domain || CONSTANTS.WILDCARD, '\\n\\n', message);\n        }\n\n        if (win === window && !CONFIG.ALLOW_SAME_ORIGIN) {\n            throw new Error('Attemping to send message to self');\n        }\n\n        if (isWindowClosed(win)) {\n            throw new Error('Window is closed');\n        }\n\n        let messages = [];\n\n        let serializedMessage = jsonStringify({\n            [ CONSTANTS.WINDOW_PROPS.POSTROBOT ]: message\n        }, null, 2);\n\n        return ZalgoPromise.map(Object.keys(SEND_MESSAGE_STRATEGIES), strategyName => {\n\n            return ZalgoPromise.try(() => {\n\n                if (!CONFIG.ALLOWED_POST_MESSAGE_METHODS[strategyName]) {\n                    throw new Error(`Strategy disallowed: ${ strategyName }`);\n                }\n\n                return SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\n            }).then(() => {\n                messages.push(`${ strategyName }: success`);\n                return true;\n            }, err => {\n                messages.push(`${ strategyName }: ${ stringifyError(err) }\\n`);\n                return false;\n            });\n\n        }).then(results => {\n\n            let success = results.some(Boolean);\n            let status = `${ message.type } ${ message.name } ${ success ? 'success' : 'error' }:\\n  - ${ messages.join('\\n  - ') }\\n`;\n\n            if (!success) {\n                throw new Error(status);\n            }\n        });\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/send/index.js","/* @flow */\n\nimport { type ZalgoPromise } from 'zalgo-promise/src';\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { matchDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { global } from '../global';\nimport { isRegex } from '../lib';\nimport { CONSTANTS } from '../conf';\n\nexport function resetListeners() {\n    global.responseListeners = {};\n    global.requestListeners  = {};\n}\n\nglobal.responseListeners = global.responseListeners || {};\nglobal.requestListeners  = global.requestListeners  || {};\nglobal.WINDOW_WILDCARD   = global.WINDOW_WILDCARD   || new (function WindowWildcard() { /* pass */ })();\n\nglobal.erroredResponseListeners = global.erroredResponseListeners || {};\n\nconst __DOMAIN_REGEX__ = '__domain_regex__';\n\nexport type RequestListenerType = {\n    handler : ({ source : CrossDomainWindowType, origin : string, data : Object }) => (mixed | ZalgoPromise<mixed>),\n    handleError : (err : mixed) => void,\n    window : ?CrossDomainWindowType,\n    name : string,\n    domain : string | RegExp | Array<string>\n};\n\nexport type ResponseListenerType = {\n    name : string,\n    window : CrossDomainWindowType,\n    domain : (string | Array<string> | RegExp),\n    respond : (err : ?mixed, result : ?Object) => void,\n    ack? : ?boolean\n};\n\nexport function addResponseListener(hash : string, listener : ResponseListenerType) {\n    global.responseListeners[hash] = listener;\n}\n\nexport function getResponseListener(hash : string) : ResponseListenerType {\n    return global.responseListeners[hash];\n}\n\nexport function deleteResponseListener(hash : string) {\n    delete global.responseListeners[hash];\n}\n\nexport function markResponseListenerErrored(hash : string) {\n    global.erroredResponseListeners[hash] = true;\n}\n\nexport function isResponseListenerErrored(hash : string) : boolean {\n    return Boolean(global.erroredResponseListeners[hash]);\n}\n\nexport function getRequestListener({ name, win, domain } : { name : string, win : ?CrossDomainWindowType, domain : ?(string | RegExp) }) : ?RequestListenerType {\n\n    if (win === CONSTANTS.WILDCARD) {\n        win = null;\n    }\n\n    if (domain === CONSTANTS.WILDCARD) {\n        domain = null;\n    }\n\n    if (!name) {\n        throw new Error(`Name required to get request listener`);\n    }\n\n    let nameListeners = global.requestListeners[name];\n\n    if (!nameListeners) {\n        return;\n    }\n\n    for (let winQualifier of [ win, global.WINDOW_WILDCARD ]) {\n\n        let winListeners = winQualifier && nameListeners.get(winQualifier);\n\n        if (!winListeners) {\n            continue;\n        }\n\n        if (domain && typeof domain === 'string') {\n            if (winListeners[domain]) {\n                return winListeners[domain];\n            }\n\n            if (winListeners[__DOMAIN_REGEX__]) {\n                for (let { regex, listener } of winListeners[__DOMAIN_REGEX__]) {\n                    if (matchDomain(regex, domain)) {\n                        return listener;\n                    }\n                }\n            }\n        }\n\n        if (winListeners[CONSTANTS.WILDCARD]) {\n            return winListeners[CONSTANTS.WILDCARD];\n        }\n    }\n}\n\n// eslint-disable-next-line complexity\nexport function addRequestListener({ name, win, domain } : { name : string, win : ?CrossDomainWindowType, domain : ?(string | RegExp | Array<string>) }, listener : RequestListenerType) : { cancel : () => void } {\n\n    if (!name || typeof name !== 'string') {\n        throw new Error(`Name required to add request listener`);\n    }\n\n    if (Array.isArray(win)) {\n        let listenersCollection = [];\n\n        for (let item of win) {\n            listenersCollection.push(addRequestListener({ name, domain, win: item }, listener));\n        }\n\n        return {\n            cancel() {\n                for (let cancelListener of listenersCollection) {\n                    cancelListener.cancel();\n                }\n            }\n        };\n    }\n\n    if (Array.isArray(domain)) {\n        let listenersCollection = [];\n\n        for (let item of domain) {\n            listenersCollection.push(addRequestListener({ name, win, domain: item }, listener));\n        }\n\n        return {\n            cancel() {\n                for (let cancelListener of listenersCollection) {\n                    cancelListener.cancel();\n                }\n            }\n        };\n    }\n\n    let existingListener = getRequestListener({ name, win, domain });\n\n    if (!win || win === CONSTANTS.WILDCARD) {\n        win = global.WINDOW_WILDCARD;\n    }\n\n    domain = domain || CONSTANTS.WILDCARD;\n\n    if (existingListener) {\n        if (win && domain) {\n            throw new Error(`Request listener already exists for ${ name } on domain ${ domain.toString() } for ${ win === global.WINDOW_WILDCARD ? 'wildcard' : 'specified' } window`);\n        } else if (win) {\n            throw new Error(`Request listener already exists for ${ name } for ${ win === global.WINDOW_WILDCARD ? 'wildcard' : 'specified' } window`);\n        } else if (domain) {\n            throw new Error(`Request listener already exists for ${ name } on domain ${ domain.toString() }`);\n        } else {\n            throw new Error(`Request listener already exists for ${ name }`);\n        }\n    }\n\n    let requestListeners = global.requestListeners;\n\n    let nameListeners = requestListeners[name];\n\n    if (!nameListeners) {\n        nameListeners = new WeakMap();\n        requestListeners[name] = nameListeners;\n    }\n\n    let winListeners  = nameListeners.get(win);\n\n    if (!winListeners) {\n        winListeners = {};\n        nameListeners.set(win, winListeners);\n    }\n\n    let strDomain = domain.toString();\n\n    let regexListeners = winListeners[__DOMAIN_REGEX__];\n    let regexListener;\n\n    if (isRegex(domain)) {\n\n        if (!regexListeners) {\n            regexListeners = [];\n            winListeners[__DOMAIN_REGEX__] = regexListeners;\n        }\n\n        regexListener = { regex: domain, listener };\n\n        regexListeners.push(regexListener);\n\n    } else {\n        winListeners[strDomain] = listener;\n    }\n\n    return {\n        cancel() {\n            if (!winListeners) {\n                return;\n            }\n\n            delete winListeners[strDomain];\n\n            if (win && Object.keys(winListeners).length === 0) {\n                nameListeners.delete(win);\n            }\n\n            if (regexListener) {\n                regexListeners.splice(regexListeners.indexOf(regexListener, 1));\n            }\n        }\n\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/listeners.js","/* @flow */\n\nimport { ZalgoPromise } from 'zalgo-promise/src';\nimport { isWindowClosed, matchDomain, stringifyDomainPattern, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONSTANTS } from '../../conf';\nimport { stringifyError, noop } from '../../lib';\nimport { sendMessage } from '../send';\nimport { getRequestListener, getResponseListener, deleteResponseListener, isResponseListenerErrored } from '../listeners';\n\nexport let RECEIVE_MESSAGE_TYPES = {\n\n    [ CONSTANTS.POST_MESSAGE_TYPE.ACK ](source : CrossDomainWindowType, origin : string, message : Object) {\n\n        if (isResponseListenerErrored(message.hash)) {\n            return;\n        }\n\n        let options = getResponseListener(message.hash);\n\n        if (!options) {\n            throw new Error(`No handler found for post message ack for message: ${ message.name } from ${ origin } in ${ window.location.protocol }//${ window.location.host }${ window.location.pathname }`);\n        }\n\n        if (!matchDomain(options.domain, origin)) {\n            throw new Error(`Ack origin ${ origin } does not match domain ${ options.domain.toString() }`);\n        }\n\n        options.ack = true;\n    },\n\n    [ CONSTANTS.POST_MESSAGE_TYPE.REQUEST ](source : CrossDomainWindowType, origin : string, message : Object) : ZalgoPromise<void> {\n\n        let options = getRequestListener({ name: message.name, win: source, domain: origin });\n\n        function respond(data) : ZalgoPromise<void> {\n\n            if (message.fireAndForget || isWindowClosed(source)) {\n                return ZalgoPromise.resolve();\n            }\n\n            return sendMessage(source, {\n                target: message.originalSource,\n                hash:   message.hash,\n                name:   message.name,\n                ...data\n            }, origin);\n        }\n\n        return ZalgoPromise.all([\n\n            respond({\n                type: CONSTANTS.POST_MESSAGE_TYPE.ACK\n            }),\n\n            ZalgoPromise.try(() => {\n\n                if (!options) {\n                    throw new Error(`No handler found for post message: ${ message.name } from ${ origin } in ${ window.location.protocol }//${ window.location.host }${ window.location.pathname }`);\n                }\n\n                if (!matchDomain(options.domain, origin)) {\n                    throw new Error(`Request origin ${ origin } does not match domain ${ options.domain.toString() }`);\n                }\n\n                let data = message.data;\n\n                return options.handler({ source, origin, data });\n\n            }).then(data => {\n\n                return respond({\n                    type: CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,\n                    ack:  CONSTANTS.POST_MESSAGE_ACK.SUCCESS,\n                    data\n                });\n\n            }, err => {\n\n                let error = stringifyError(err).replace(/^Error: /, '');\n                // $FlowFixMe\n                let code = err.code;\n\n                return respond({\n                    type: CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,\n                    ack:  CONSTANTS.POST_MESSAGE_ACK.ERROR,\n                    error,\n                    code\n                });\n            })\n\n        ]).then(noop).catch(err => {\n\n            if (options && options.handleError) {\n                return options.handleError(err);\n            } else {\n                throw err;\n            }\n        });\n    },\n\n    [ CONSTANTS.POST_MESSAGE_TYPE.RESPONSE ](source : CrossDomainWindowType, origin : string, message : Object) : void | ZalgoPromise<void> {\n\n        if (isResponseListenerErrored(message.hash)) {\n            return;\n        }\n\n        let options = getResponseListener(message.hash);\n\n        if (!options) {\n            throw new Error(`No handler found for post message response for message: ${ message.name } from ${ origin } in ${ window.location.protocol }//${ window.location.host }${ window.location.pathname }`);\n        }\n\n        if (!matchDomain(options.domain, origin)) {\n            throw new Error(`Response origin ${ origin } does not match domain ${ stringifyDomainPattern(options.domain) }`);\n        }\n\n        deleteResponseListener(message.hash);\n\n        if (message.ack === CONSTANTS.POST_MESSAGE_ACK.ERROR) {\n            let err = new Error(message.error);\n            if (message.code) {\n                // $FlowFixMe\n                err.code = message.code;\n            }\n            return options.respond(err, null);\n        } else if (message.ack === CONSTANTS.POST_MESSAGE_ACK.SUCCESS) {\n            let data = message.data || message.response;\n\n            return options.respond(null, { source, origin, data });\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/receive/types.js","/* @flow */\n\nimport { isWindowClosed, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONSTANTS, POST_MESSAGE_NAMES_LIST } from '../../conf';\nimport { deserializeMethods, jsonParse, addEventListener, noop } from '../../lib';\nimport { global } from '../../global';\n\nimport { RECEIVE_MESSAGE_TYPES } from './types';\n\nglobal.receivedMessages = global.receivedMessages || [];\n\ntype MessageEvent = {\n    source : CrossDomainWindowType,\n    origin : string,\n    data : string\n};\n\nfunction parseMessage(message : string) : ?Object {\n\n    let parsedMessage;\n\n    try {\n        parsedMessage = jsonParse(message);\n    } catch (err) {\n        return;\n    }\n\n    if (!parsedMessage) {\n        return;\n    }\n\n    if (typeof parsedMessage !== 'object' || parsedMessage === null) {\n        return;\n    }\n\n    parsedMessage = parsedMessage[CONSTANTS.WINDOW_PROPS.POSTROBOT];\n\n    if (!parsedMessage || typeof parsedMessage !== 'object' || parsedMessage === null) {\n        return;\n    }\n\n    if (!parsedMessage.type || typeof parsedMessage.type !== 'string') {\n        return;\n    }\n\n    if (!RECEIVE_MESSAGE_TYPES[parsedMessage.type]) {\n        return;\n    }\n\n    return parsedMessage;\n}\n\n\nexport function receiveMessage(event : MessageEvent) {\n\n    if (!window || window.closed) {\n        throw new Error(`Message recieved in closed window`);\n    }\n\n    try {\n        if (!event.source) {\n            return;\n        }\n    } catch (err) {\n        return;\n    }\n\n    let { source, origin, data } = event;\n\n    let message = parseMessage(data);\n\n    if (!message) {\n        return;\n    }\n\n    if (!message.sourceDomain || typeof message.sourceDomain !== 'string') {\n        throw new Error(`Expected message to have sourceDomain`);\n    }\n\n    if (message.sourceDomain.indexOf(CONSTANTS.MOCK_PROTOCOL) === 0 || message.sourceDomain.indexOf(CONSTANTS.FILE_PROTOCOL) === 0) {\n        origin = message.sourceDomain;\n    }\n\n    if (global.receivedMessages.indexOf(message.id) === -1) {\n        global.receivedMessages.push(message.id);\n    } else {\n        return;\n    }\n\n    if (__DEBUG__) {\n        let level;\n\n        if (POST_MESSAGE_NAMES_LIST.indexOf(message.name) !== -1 || message.type === CONSTANTS.POST_MESSAGE_TYPE.ACK) {\n            level = 'debug';\n        } else if (message.ack === 'error') {\n            level = 'error';\n        } else {\n            level = 'info';\n        }\n        \n        // eslint-disable-next-line no-console\n        console[level]('postrobot_receive', message.type.replace(/^postrobot_message_/, ''), '::', message.name, '::', origin, '\\n\\n', message);\n    }\n\n    if (isWindowClosed(source) && !message.fireAndForget) {\n        return;\n    }\n\n    if (message.data) {\n        message.data = deserializeMethods(source, origin, message.data);\n    }\n\n    RECEIVE_MESSAGE_TYPES[message.type](source, origin, message);\n}\n\nexport function messageListener(event : { source : CrossDomainWindowType, origin : string, data : string, sourceElement : CrossDomainWindowType, originalEvent? : { origin : string } }) {\n\n    try {\n        noop(event.source);\n    } catch (err) {\n        return;\n    }\n\n    // $FlowFixMe\n    let messageEvent : MessageEvent = {\n        source: event.source || event.sourceElement,\n        origin: event.origin || (event.originalEvent && event.originalEvent.origin),\n        data:   event.data\n    };\n\n    if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n        try {\n            require('../../compat').emulateIERestrictions(messageEvent.source, window);\n        } catch (err) {\n            return;\n        }\n    }\n\n    receiveMessage(messageEvent);\n}\n\nexport function listenForMessages() {\n    addEventListener(window, 'message', messageListener);\n}\n\nglobal.receiveMessage = receiveMessage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/receive/index.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\nimport { getAncestor, isAncestor, isWindowClosed, getDomain, matchDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONFIG, CONSTANTS } from '../conf';\nimport { sendMessage, addResponseListener, deleteResponseListener, markResponseListenerErrored, type ResponseListenerType } from '../drivers';\nimport { uniqueID, onChildWindowReady, sayHello, isRegex } from '../lib';\nimport { global } from '../global';\n\nglobal.requestPromises = global.requestPromises || new WeakMap();\n\ntype WindowResolverType = CrossDomainWindowType | string | HTMLIFrameElement;\n\ntype RequestOptionsType = {\n    window? : ?WindowResolverType,\n    domain? : ?(string | Array<string> | RegExp),\n    name? : ?string,\n    data? : ?Object,\n    fireAndForget? : ?boolean,\n    timeout? : ?number\n};\n\ntype ResponseMessageEvent = {\n    source : CrossDomainWindowType,\n    origin : string,\n    data : Object\n};\n\nexport function request(options : RequestOptionsType) : ZalgoPromise<ResponseMessageEvent> {\n\n    let prom = ZalgoPromise.try(() => {\n\n        if (!options.name) {\n            throw new Error('Expected options.name');\n        }\n\n        let name = options.name;\n        let targetWindow : ?CrossDomainWindowType;\n        let domain : string | Array<string> | RegExp;\n\n        if (typeof options.window === 'string') {\n            let el = document.getElementById(options.window);\n\n            if (!el) {\n                throw new Error(`Expected options.window ${ Object.prototype.toString.call(options.window) } to be a valid element id`);\n            }\n\n            if (el.tagName.toLowerCase() !== 'iframe') {\n                throw new Error(`Expected options.window ${ Object.prototype.toString.call(options.window) } to be an iframe`);\n            }\n\n            // $FlowFixMe\n            if (!el.contentWindow) {\n                throw new Error('Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.');\n            }\n\n            // $FlowFixMe\n            targetWindow = el.contentWindow;\n\n        } else if (options.window instanceof HTMLIFrameElement) {\n\n            if (options.window.tagName.toLowerCase() !== 'iframe') {\n                throw new Error(`Expected options.window ${ Object.prototype.toString.call(options.window) } to be an iframe`);\n            }\n\n            if (options.window && !options.window.contentWindow) {\n                throw new Error('Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.');\n            }\n\n            if (options.window && options.window.contentWindow) {\n                // $FlowFixMe\n                targetWindow = options.window.contentWindow;\n            }\n        } else {\n            targetWindow = options.window;\n        }\n\n        if (!targetWindow) {\n            throw new Error('Expected options.window to be a window object, iframe, or iframe element id.');\n        }\n\n        const win = targetWindow;\n\n        domain = options.domain || CONSTANTS.WILDCARD;\n\n        let hash = `${ options.name }_${ uniqueID() }`;\n\n        if (isWindowClosed(win)) {\n            throw new Error('Target window is closed');\n        }\n\n        let hasResult = false;\n\n        let requestPromises = global.requestPromises.get(win);\n\n        if (!requestPromises) {\n            requestPromises = [];\n            global.requestPromises.set(win, requestPromises);\n        }\n\n        let requestPromise = ZalgoPromise.try(() => {\n\n            if (isAncestor(window, win)) {\n                return onChildWindowReady(win, options.timeout || CONFIG.CHILD_WINDOW_TIMEOUT);\n            }\n\n        }).then(({ origin } = {}) => {\n\n            if (isRegex(domain) && !origin) {\n                return sayHello(win);\n            }\n\n        }).then(({ origin } = {}) => {\n\n            if (isRegex(domain)) {\n                if (!matchDomain(domain, origin)) {\n                    throw new Error(`Remote window domain ${ origin } does not match regex: ${ domain.toString() }`);\n                }\n\n                domain = origin;\n            }\n\n            if (typeof domain !== 'string' && !Array.isArray(domain)) {\n                throw new TypeError(`Expected domain to be a string or array`);\n            }\n\n            const actualDomain = domain;\n\n            return new ZalgoPromise((resolve, reject) => {\n\n                let responseListener : ResponseListenerType;\n\n                if (!options.fireAndForget) {\n                    responseListener = {\n                        name,\n                        window: win,\n                        domain: actualDomain,\n                        respond(err, result) {\n                            if (!err) {\n                                hasResult = true;\n                                requestPromises.splice(requestPromises.indexOf(requestPromise, 1));\n                            }\n\n                            if (err) {\n                                reject(err);\n                            } else {\n                                resolve(result);\n                            }\n                        }\n                    };\n\n                    addResponseListener(hash, responseListener);\n                }\n\n                sendMessage(win, {\n                    type:          CONSTANTS.POST_MESSAGE_TYPE.REQUEST,\n                    hash,\n                    name,\n                    data:          options.data,\n                    fireAndForget: options.fireAndForget\n                }, actualDomain).catch(reject);\n\n                if (options.fireAndForget) {\n                    return resolve();\n                }\n\n                let ackTimeout = CONFIG.ACK_TIMEOUT;\n                let resTimeout = options.timeout || CONFIG.RES_TIMEOUT;\n\n                let cycleTime = 100;\n\n                let cycle = () => {\n\n                    if (hasResult) {\n                        return;\n                    }\n\n                    if (isWindowClosed(win)) {\n\n                        if (!responseListener.ack) {\n                            return reject(new Error(`Window closed for ${ name } before ack`));\n                        }\n\n                        return reject(new Error(`Window closed for ${ name } before response`));\n                    }\n\n                    ackTimeout = Math.max(ackTimeout - cycleTime, 0);\n                    if (resTimeout !== -1) {\n                        resTimeout = Math.max(resTimeout - cycleTime, 0);\n                    }\n\n                    let hasAck = responseListener.ack;\n\n                    if (hasAck) {\n\n                        if (resTimeout === -1) {\n                            return;\n                        }\n\n                        cycleTime = Math.min(resTimeout, 2000);\n\n                    } else if (ackTimeout === 0) {\n                        return reject(new Error(`No ack for postMessage ${ name } in ${ getDomain() } in ${ CONFIG.ACK_TIMEOUT }ms`));\n\n                    } else if (resTimeout === 0) {\n                        return reject(new Error(`No response for postMessage ${ name } in ${ getDomain() } in ${ options.timeout || CONFIG.RES_TIMEOUT }ms`));\n                    }\n\n                    setTimeout(cycle, cycleTime);\n                };\n\n                setTimeout(cycle, cycleTime);\n            });\n        });\n\n        requestPromise.catch(() => {\n            markResponseListenerErrored(hash);\n            deleteResponseListener(hash);\n        });\n\n        requestPromises.push(requestPromise);\n\n        return requestPromise;\n    });\n\n    return prom;\n}\n\nexport function send(window : WindowResolverType, name : string, data : ?Object, options : ?RequestOptionsType) : ZalgoPromise<ResponseMessageEvent> {\n\n    options = options || {};\n    options.window = window;\n    options.name = name;\n    options.data = data;\n\n    return request(options);\n}\n\nexport function sendToParent(name : string, data : ?Object, options : ?RequestOptionsType) : ZalgoPromise<ResponseMessageEvent> {\n\n    let win = getAncestor();\n\n    if (!win) {\n        return new ZalgoPromise((resolve, reject) => reject(new Error('Window does not have a parent')));\n    }\n\n    return send(win, name, data, options);\n}\n\nexport function client(options : RequestOptionsType = {}) : { send : (string, ?Object) => ZalgoPromise<ResponseMessageEvent> } {\n\n    if (!options.window) {\n        throw new Error(`Expected options.window`);\n    }\n\n    const win = options.window;\n\n    return {\n        send(name : string, data : ?Object) : ZalgoPromise<ResponseMessageEvent> {\n            return send(win, name, data, options);\n        }\n    };\n}\n\nglobal.send = send;\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/client.js","/* @flow */\n\nimport { isWindowClosed, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { once as onceFunction, safeInterval } from '../lib';\nimport { addRequestListener, type RequestListenerType } from '../drivers';\nimport { CONSTANTS } from '../conf';\nimport { global } from '../global';\n\ntype ErrorHandlerType = (err : mixed) => void;\ntype HandlerType = ({ source : CrossDomainWindowType, origin : string, data : Object }) => (void | mixed | ZalgoPromise<mixed>);\n\ntype ServerOptionsType = {\n    handler? : ?HandlerType,\n    errorHandler? : ?ErrorHandlerType,\n    window? : CrossDomainWindowType,\n    name? : ?string,\n    domain? : ?(string | RegExp | Array<string>),\n    once? : ?boolean,\n    errorOnClose? : ?boolean\n};\n\nexport function listen(options : ServerOptionsType) : { cancel : () => void } {\n\n    if (!options.name) {\n        throw new Error('Expected options.name');\n    }\n\n    if (!options.handler) {\n        throw new Error('Expected options.handler');\n    }\n\n    const name = options.name;\n    const win = options.window;\n    const domain = options.domain;\n\n    let listenerOptions : RequestListenerType = {\n        handler:     options.handler,\n        handleError: options.errorHandler || (err => {\n            throw err;\n        }),\n        window: win,\n        domain: domain || CONSTANTS.WILDCARD,\n        name\n    };\n\n    let requestListener = addRequestListener({ name, win, domain }, listenerOptions);\n\n    if (options.once) {\n        let handler = listenerOptions.handler;\n        listenerOptions.handler = onceFunction(function listenOnce() : mixed | ZalgoPromise<mixed> {\n            requestListener.cancel();\n            return handler.apply(this, arguments);\n        });\n    }\n\n    if (listenerOptions.window && options.errorOnClose) {\n        let interval = safeInterval(() => {\n            if (win && typeof win === 'object' && isWindowClosed(win)) {\n                interval.cancel();\n                listenerOptions.handleError(new Error('Post message target window is closed'));\n            }\n        }, 50);\n    }\n\n    return {\n        cancel() {\n            requestListener.cancel();\n        }\n    };\n}\n\nexport function on(name : string, options : ServerOptionsType | HandlerType, handler : ?HandlerType) : { cancel : () => void } {\n\n    if (typeof options === 'function') {\n        handler = options;\n        options = {};\n    }\n\n    options = options || {};\n\n    options.name = name;\n    options.handler = handler || options.handler;\n\n    return listen(options);\n}\n\nexport function once(name : string, options : ?(ServerOptionsType | HandlerType) = {}, handler : ?HandlerType) : ZalgoPromise<{ source : mixed, origin : string, data : Object }> {\n\n    if (typeof options === 'function') {\n        handler = options;\n        options = {};\n    }\n\n    options = options || {};\n    handler = handler || options.handler;\n    let errorHandler = options.errorHandler;\n\n    let promise = new ZalgoPromise((resolve, reject) => {\n\n        options = options || {};\n\n        options.name = name;\n        options.once = true;\n\n        options.handler = (event) => {\n            resolve(event);\n            if (handler) {\n                return handler(event);\n            }\n        };\n\n        options.errorHandler = (err) => {\n            reject(err);\n            if (errorHandler) {\n                return errorHandler(err);\n            }\n        };\n    });\n\n    let onceListener = listen(options);\n    promise.cancel = onceListener.cancel;\n\n    return promise;\n}\n\nexport function listener(options : ServerOptionsType = {}) : { on : (name : string, handler : HandlerType) => { cancel : () => void } } {\n\n    return {\n        on(name : string, handler : HandlerType) : { cancel : () => void } {\n            return on(name, options, handler);\n        }\n    };\n}\n\nglobal.on = on;\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/server.js","/* @flow */\n\nimport { CONSTANTS } from '../conf';\nimport { messageListener } from '../drivers';\n\nexport { CONFIG, CONSTANTS } from '../conf';\n\nexport function disable() {\n    delete window[CONSTANTS.WINDOW_PROPS.POSTROBOT];\n    window.removeEventListener('message', messageListener);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/config.js","/* @flow */\n\nimport { getAncestor } from 'cross-domain-utils/src';\n\nexport * from './client';\nexport * from './server';\nexport * from './config';\n\nexport let parent = getAncestor();\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/index.js","/* @flow */\n\nimport { type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { global } from './global';\n\nexport function cleanUpWindow(win : CrossDomainWindowType) {\n\n    // global.tunnelWindows\n    // global.bridges\n    // global.popupWindowsByName\n    // global.responseListeners\n    // global.requestListeners\n\n    let requestPromises = global.requestPromises.get(win);\n\n    if (requestPromises) {\n        for (let promise of requestPromises) {\n            promise.reject(new Error(`No response from window - cleaned up`));\n        }\n    }\n\n    if (global.popupWindowsByWin) {\n        global.popupWindowsByWin.delete(win);\n    }\n\n    if (global.remoteWindows) {\n        global.remoteWindows.delete(win);\n    }\n\n    global.requestPromises.delete(win);\n    global.methods.delete(win);\n    global.readyPromises.delete(win);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/clean.js","/* @flow */\n\nimport { initOnReady, listenForMethods } from './lib';\nimport { listenForMessages } from './drivers';\nimport { global } from './global';\nimport { on, send } from './public';\n\nexport * from './public';\nexport { cleanUpWindow } from './clean';\nexport { ZalgoPromise as Promise } from 'zalgo-promise/src';\nexport let bridge = __POST_ROBOT__.__IE_POPUP_SUPPORT__ ? require('./bridge/interface') : null;\n\nexport function init() {\n    if (!global.initialized) {\n        listenForMessages();\n\n        if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n            require('./bridge').openTunnelToOpener();\n        }\n\n        initOnReady();\n        listenForMethods({ on, send });\n    }\n\n    global.initialized = true;\n}\n\ninit();\n\n\n\n// WEBPACK FOOTER //\n// ./src/interface.js","/* @flow */\n\n// eslint-disable-next-line import/no-namespace\nimport * as INTERFACE from './interface';\n\nexport * from './interface';\nexport default INTERFACE;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/* @flow */\n\nexport function isRegex(item : mixed) : boolean {\n    return Object.prototype.toString.call(item) === '[object RegExp]';\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/util.js","/* @flow */\n/* eslint max-lines: 0 */\n\nimport { isRegex, noop } from './util';\nimport type { CrossDomainWindowType, SameDomainWindowType, DomainMatcher } from './types';\nimport { PROTOCOL, WILDCARD } from './constants';\n\nlet IE_WIN_ACCESS_ERROR = 'Call was rejected by callee.\\r\\n';\n\nexport function isFileProtocol(win : SameDomainWindowType = window) : boolean {\n    return win.location.protocol === PROTOCOL.FILE;\n}\n\nexport function isAboutProtocol(win : SameDomainWindowType = window) : boolean {\n    return win.location.protocol === PROTOCOL.ABOUT;\n}\n\nexport function getParent(win : ?CrossDomainWindowType) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    try {\n        if (win.parent && win.parent !== win) {\n            return win.parent;\n        }\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function getOpener(win : ?CrossDomainWindowType) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    // Make sure we're not actually an iframe which has had window.open() called on us\n    if (getParent(win)) {\n        return;\n    }\n\n    try {\n        return win.opener;\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function canReadFromWindow(win : CrossDomainWindowType | SameDomainWindowType) : boolean {\n    try {\n        // $FlowFixMe\n        noop(win && win.location && win.location.href);\n        return true;\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function getActualDomain(win : ?SameDomainWindowType) : string {\n\n    win = win || window;\n\n    let location = win.location;\n\n    if (!location) {\n        throw new Error(`Can not read window location`);\n    }\n\n    let protocol = location.protocol;\n\n    if (!protocol) {\n        throw new Error(`Can not read window protocol`);\n    }\n\n    if (protocol === PROTOCOL.FILE) {\n        return `${ PROTOCOL.FILE }//`;\n    }\n\n    if (protocol === PROTOCOL.ABOUT) {\n\n        let parent = getParent(win);\n        if (parent && canReadFromWindow(parent)) {\n            // $FlowFixMe\n            return getActualDomain(parent);\n        }\n\n        return `${ PROTOCOL.ABOUT }//`;\n    }\n\n    let host = location.host;\n\n    if (!host) {\n        throw new Error(`Can not read window host`);\n    }\n\n    return `${ protocol }//${ host }`;\n}\n\nexport function getDomain(win : ?SameDomainWindowType) : string {\n\n    win = win || window;\n\n    let domain = getActualDomain(win);\n\n    if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n        return win.mockDomain;\n    }\n\n    return domain;\n}\n\nexport function isBlankDomain(win : CrossDomainWindowType) : boolean {\n    try {\n        // $FlowFixMe\n        if (!win.location.href) {\n            return true;\n        }\n\n        if (win.location.href === 'about:blank') {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function isActuallySameDomain(win : CrossDomainWindowType) : boolean {\n\n    try {\n        if (win === window) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        let desc = Object.getOwnPropertyDescriptor(win, 'location');\n\n        if (desc && desc.enumerable === false) {\n            return false;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        // $FlowFixMe\n        if (isAboutProtocol(win) && canReadFromWindow(win)) {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        // $FlowFixMe\n        if (getActualDomain(win) === getActualDomain(window)) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function isSameDomain(win : CrossDomainWindowType | SameDomainWindowType) : boolean {\n\n    if (!isActuallySameDomain(win)) {\n        return false;\n    }\n\n    try {\n\n        if (win === window) {\n            return true;\n        }\n\n        // $FlowFixMe\n        if (isAboutProtocol(win) && canReadFromWindow(win)) {\n            return true;\n        }\n\n        // $FlowFixMe\n        if (getDomain(window) === getDomain(win)) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\n\nexport function assertSameDomain(win : CrossDomainWindowType | SameDomainWindowType) : SameDomainWindowType {\n    if (!isSameDomain(win)) {\n        throw new Error(`Expected window to be same domain`);\n    }\n\n    // $FlowFixMe\n    return win;\n}\n\nexport function getParents(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    try {\n\n        while (win.parent !== win) {\n            result.push(win.parent);\n            win = win.parent;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return result;\n}\n\nexport function isAncestorParent(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    if (!parent || !child) {\n        return false;\n    }\n\n    let childParent = getParent(child);\n\n    if (childParent) {\n        return childParent === parent;\n    }\n\n    if (getParents(child).indexOf(parent) !== -1) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function getFrames(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    let frames;\n\n    try {\n        frames = win.frames;\n    } catch (err) {\n        frames = win;\n    }\n\n    let len;\n\n    try {\n        len = frames.length;\n    } catch (err) {\n        // pass\n    }\n\n    if (len === 0) {\n        return result;\n    }\n\n    if (len) {\n        for (let i = 0; i < len; i++) {\n\n            let frame;\n\n            try {\n                frame = frames[i];\n            } catch (err) {\n                continue;\n            }\n\n            result.push(frame);\n        }\n\n        return result;\n    }\n\n    for (let i = 0; i < 100; i++) {\n        let frame;\n\n        try {\n            frame = frames[i];\n        } catch (err) {\n            return result;\n        }\n\n        if (!frame) {\n            return result;\n        }\n\n        result.push(frame);\n    }\n\n    return result;\n}\n\n\nexport function getAllChildFrames(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    for (let frame of getFrames(win)) {\n        result.push(frame);\n\n        for (let childFrame of getAllChildFrames(frame)) {\n            result.push(childFrame);\n        }\n    }\n\n    return result;\n}\n\nexport function getTop(win : CrossDomainWindowType) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    try {\n        if (win.top) {\n            return win.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    if (getParent(win) === win) {\n        return win;\n    }\n\n    try {\n        if (isAncestorParent(window, win) && window.top) {\n            return window.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        if (isAncestorParent(win, window) && window.top) {\n            return window.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    for (let frame of getAllChildFrames(win)) {\n        try {\n            if (frame.top) {\n                return frame.top;\n            }\n        } catch (err) {\n            // pass\n        }\n\n        if (getParent(frame) === frame) {\n            return frame;\n        }\n    }\n}\n\nexport function getNextOpener(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n    return getOpener(getTop(win) || win);\n}\n\nexport function getUltimateTop(win? : CrossDomainWindowType = window) : CrossDomainWindowType {\n    let opener = getNextOpener(win);\n\n    if (opener) {\n        return getUltimateTop(opener);\n    }\n\n    return top;\n}\n\nexport function getAllFramesInWindow(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n    let top = getTop(win);\n\n    if (!top) {\n        throw new Error(`Can not determine top window`);\n    }\n\n    return [ ...getAllChildFrames(top), top ];\n}\n\nexport function getAllWindows(win? : CrossDomainWindowType = window) : $ReadOnlyArray<CrossDomainWindowType> {\n    let frames = getAllFramesInWindow(win);\n    let opener = getNextOpener(win);\n\n    if (opener) {\n        return [ ...getAllWindows(opener), ...frames ];\n    } else {\n        return frames;\n    }\n}\n\nexport function isTop(win : CrossDomainWindowType) : boolean {\n    return win === getTop(win);\n}\n\nexport function isFrameWindowClosed(frame : HTMLIFrameElement) : boolean {\n\n    if (!frame.contentWindow) {\n        return true;\n    }\n\n    if (!frame.parentNode) {\n        return true;\n    }\n\n    let doc = frame.ownerDocument;\n\n    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction safeIndexOf<T>(collection : Array<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\nlet iframeWindows = [];\nlet iframeFrames = [];\n\nexport function isWindowClosed(win : CrossDomainWindowType, allowMock : boolean = true) : boolean {\n\n    try {\n        if (win === window) {\n            return false;\n        }\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (!win) {\n            return true;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (win.closed) {\n            return true;\n        }\n\n    } catch (err) {\n\n        // I love you so much IE\n\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return false;\n        }\n\n        return true;\n    }\n\n\n    if (allowMock && isSameDomain(win)) {\n        try {\n            // $FlowFixMe\n            if (win.mockclosed) {\n                return true;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    // Mobile safari\n\n    try {\n        if (!win.parent || !win.top) {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    // Yes, this actually happens in IE. win === win errors out when the window\n    // is from an iframe, and the iframe was removed from the page.\n\n    try {\n        noop(win === win); // eslint-disable-line no-self-compare\n    } catch (err) {\n        return true;\n    }\n\n    // IE orphaned frame\n\n    let iframeIndex = safeIndexOf(iframeWindows, win);\n\n    if (iframeIndex !== -1) {\n        let frame = iframeFrames[iframeIndex];\n\n        if (frame && isFrameWindowClosed(frame)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction cleanIframes() {\n    for (let i = 0; i < iframeWindows.length; i++) {\n        let closed = false;\n\n        try {\n            closed = iframeWindows[i].closed;\n        } catch (err) {\n            // pass\n        }\n\n        if (closed) {\n            iframeFrames.splice(i, 1);\n            iframeWindows.splice(i, 1);\n        }\n    }\n}\n\nexport function linkFrameWindow(frame : HTMLIFrameElement) {\n\n    cleanIframes();\n\n    if (frame && frame.contentWindow) {\n        try {\n            iframeWindows.push(frame.contentWindow);\n            iframeFrames.push(frame);\n        } catch (err) {\n            // pass\n        }\n    }\n}\n\nexport function getUserAgent(win : ?SameDomainWindowType) : string {\n    win = win || window;\n    return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\n\n\nexport function getFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let winFrames = getFrames(win);\n\n    for (let childFrame of winFrames) {\n        try {\n            // $FlowFixMe\n            if (isSameDomain(childFrame) && childFrame.name === name && winFrames.indexOf(childFrame) !== -1) {\n                return childFrame;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    try {\n        // $FlowFixMe\n        if (winFrames.indexOf(win.frames[name]) !== -1) {\n            // $FlowFixMe\n            return win.frames[name];\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        if (winFrames.indexOf(win[name]) !== -1) {\n            return win[name];\n        }\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function findChildFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let frame = getFrameByName(win, name);\n\n    if (frame) {\n        return frame;\n    }\n\n    for (let childFrame of getFrames(win)) {\n        let namedFrame = findChildFrameByName(childFrame, name);\n\n        if (namedFrame) {\n            return namedFrame;\n        }\n    }\n}\n\nexport function findFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let frame;\n\n    frame = getFrameByName(win, name);\n\n    if (frame) {\n        return frame;\n    }\n\n    let top = getTop(win) || win;\n\n    return findChildFrameByName(top, name);\n}\n\nexport function isParent(win : CrossDomainWindowType, frame : CrossDomainWindowType) : boolean {\n\n    let frameParent = getParent(frame);\n\n    if (frameParent) {\n        return frameParent === win;\n    }\n\n    for (let childFrame of getFrames(win)) {\n        if (childFrame === frame) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isOpener(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    return parent === getOpener(child);\n}\n\nexport function getAncestor(win : ?CrossDomainWindowType) : ?CrossDomainWindowType {\n    win = win || window;\n\n    let opener = getOpener(win);\n\n    if (opener) {\n        return opener;\n    }\n\n    let parent = getParent(win);\n\n    if (parent) {\n        return parent;\n    }\n}\n\nexport function getAncestors(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let results = [];\n\n    let ancestor = win;\n\n    while (ancestor) {\n        ancestor = getAncestor(ancestor);\n        if (ancestor) {\n            results.push(ancestor);\n        }\n    }\n\n    return results;\n}\n\n\nexport function isAncestor(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    let actualParent = getAncestor(child);\n\n    if (actualParent) {\n        if (actualParent === parent) {\n            return true;\n        }\n\n        return false;\n    }\n\n    if (child === parent) {\n        return false;\n    }\n\n    if (getTop(child) === child) {\n        return false;\n    }\n\n    for (let frame of getFrames(parent)) {\n        if (frame === child) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isPopup() : boolean {\n    return Boolean(getOpener(window));\n}\n\nexport function isIframe() : boolean {\n    return Boolean(getParent(window));\n}\n\nexport function isFullpage() : boolean {\n    return Boolean(!isIframe() && !isPopup());\n}\n\nfunction anyMatch(collection1, collection2) : boolean {\n\n    for (let item1 of collection1) {\n        for (let item2 of collection2) {\n            if (item1 === item2) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nexport function getDistanceFromTop(win : CrossDomainWindowType = window) : number {\n    let distance = 0;\n    let parent = win;\n\n    while (parent) {\n        parent = getParent(parent);\n        if (parent) {\n            distance += 1;\n        }\n    }\n\n    return distance;\n}\n\nexport function getNthParent(win : CrossDomainWindowType, n : number = 1) : ?CrossDomainWindowType {\n    let parent = win;\n\n    for (let i = 0; i < n; i++) {\n        if (!parent) {\n            return;\n        }\n\n        parent = getParent(parent);\n    }\n\n    return parent;\n}\n\nexport function getNthParentFromTop(win : CrossDomainWindowType, n : number = 1) : ?CrossDomainWindowType {\n    return getNthParent(win, getDistanceFromTop(win) - n);\n}\n\nexport function isSameTopWindow(win1 : CrossDomainWindowType, win2 : CrossDomainWindowType) : boolean {\n\n    let top1 = getTop(win1) || win1;\n    let top2 = getTop(win2) || win2;\n\n    try {\n        if (top1 && top2) {\n            if (top1 === top2) {\n                return true;\n            }\n\n            return false;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    let allFrames1 = getAllFramesInWindow(win1);\n    let allFrames2 = getAllFramesInWindow(win2);\n\n    if (anyMatch(allFrames1, allFrames2)) {\n        return true;\n    }\n\n    let opener1 = getOpener(top1);\n    let opener2 = getOpener(top2);\n\n    if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n        return false;\n    }\n\n    if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n        return false;\n    }\n\n    return false;\n}\n\nexport function matchDomain(pattern : DomainMatcher, origin : DomainMatcher) : boolean {\n\n    if (typeof pattern === 'string') {\n\n        if (typeof origin === 'string') {\n            return pattern === WILDCARD || origin === pattern;\n        }\n\n        if (isRegex(origin)) {\n            return false;\n        }\n\n        if (Array.isArray(origin)) {\n            return false;\n        }\n    }\n\n    if (isRegex(pattern)) {\n\n        if (isRegex(origin)) {\n            return pattern.toString() === origin.toString();\n        }\n\n        if (Array.isArray(origin)) {\n            return false;\n        }\n\n        // $FlowFixMe\n        return Boolean(origin.match(pattern));\n    }\n\n    if (Array.isArray(pattern)) {\n\n        if (Array.isArray(origin)) {\n            return JSON.stringify(pattern) === JSON.stringify(origin);\n        }\n\n        if (isRegex(origin)) {\n            return false;\n        }\n\n        return pattern.some(subpattern => matchDomain(subpattern, origin));\n    }\n\n    return false;\n}\n\nexport function stringifyDomainPattern(pattern : DomainMatcher) : string {\n    if (Array.isArray(pattern)) {\n        return `(${ pattern.join(' | ') })`;\n    } else if (isRegex(pattern)) {\n        return `RegExp(${ pattern.toString() }`;\n    } else {\n        return pattern.toString();\n    }\n}\n\nexport function getDomainFromUrl(url : string) : string {\n\n    let domain;\n\n    if (url.match(/^(https?|mock|file):\\/\\//)) {\n        domain = url;\n    } else {\n        return getDomain();\n    }\n\n    domain = domain.split('/').slice(0, 3).join('/');\n\n    return domain;\n}\n\nexport function onCloseWindow(win : CrossDomainWindowType, callback : Function, delay : number = 1000, maxtime : number = Infinity) : { cancel : () => void } {\n\n    let timeout;\n\n    let check = () => {\n\n        if (isWindowClosed(win)) {\n\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n\n            return callback();\n        }\n\n        if (maxtime <= 0) {\n            clearTimeout(timeout);\n        } else {\n            maxtime -= delay;\n            timeout = setTimeout(check, delay);\n        }\n    };\n\n    check();\n\n    return {\n        cancel() {\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n        }\n    };\n}\n\n// eslint-disable-next-line complexity\nexport function isWindow(obj : Object) : boolean {\n\n    try {\n        if (obj === window) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (Object.prototype.toString.call(obj) === '[object Window]') {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (window.Window && obj instanceof window.Window) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.self === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.parent === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.top === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        noop(obj === obj);  // eslint-disable-line no-self-compare\n\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        noop(obj && obj.__cross_domain_utils_window_check__);\n\n    } catch (err) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function isBrowser() : boolean {\n    return (typeof window !== 'undefined' && typeof window.location !== 'undefined');\n}\n\nexport function isCurrentDomain(domain : string) : boolean {\n    if (!isBrowser()) {\n        return false;\n    }\n\n    return (getDomain() === domain);\n}\n\nexport function isMockDomain(domain : string) : boolean {\n    return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\n\nexport function normalizeMockUrl(url : string) : string {\n    if (!isMockDomain(getDomainFromUrl(url))) {\n        return url;\n    }\n\n    if (!__TEST__) {\n        throw new Error(`Mock urls not supported out of test mode`);\n    }\n\n    return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/utils.js"],"sourceRoot":""}